---
title: "Predictive Analytics"
subtitle: "Machine Learning Insights for Job Market Analysis"
format:
  html:
    theme: cosmo
    toc: True
    code-fold: True
    code-tools: True
    embed-resources: True
    css: styles.css
    self-contained: true
execute:
  echo: False
  warning: False
  message: False
  cache: true
python:
  type: venv
  environment: .venv
---

## Overview

This page demonstrates basic predictive analytics using the job market data. We focus on simple, interpretable models that provide actionable insights for job seekers.

```{python}
#| label: data-loading
#| output: false

# Load processed data using centralized pipeline
from src.data import load_analysis_data
from src.config.column_mapping import get_analysis_column
from src.visualization.charts import display_figure
import pandas as pd
import numpy as np

df = load_analysis_data("predictive")

# Get standardized column names
salary_col = get_analysis_column('salary')
city_col = get_analysis_column('city')
```

```{python}
#| label: data-summary
#| output: asis

from IPython.display import Markdown, display

summary_text = f"""
**Data Loaded:**

- **Records**: {len(df):,}
- **Salary Column**: `{salary_col}`
- **Location Column**: `{city_col}`
"""

display(Markdown(summary_text))
```

## Salary Distribution Analysis

Understanding the overall salary landscape helps set realistic expectations.

```{python}
#| label: salary-distribution

# Use abstraction layer for salary distribution
from src.visualization import SalaryVisualizer

visualizer = SalaryVisualizer(df)
fig = visualizer.create_salary_distribution_histogram()

# Display figure with error handling
try:
    display_figure(fig, "salary_distribution_histogram")
except Exception as e:
    print(f"Chart display error: {e}")
    # Fallback: show basic info
    print(f"Median salary: ${df[salary_col].median():,.0f}")
    print(f"Salary range: ${df[salary_col].min():,.0f} - ${df[salary_col].max():,.0f}")
```

```{python}
#| label: salary-statistics
#| output: asis

from IPython.display import Markdown, display

# Calculate salary statistics
median_salary = df[salary_col].median()
mean_salary = df[salary_col].mean()
q25_salary = df[salary_col].quantile(0.25)
q75_salary = df[salary_col].quantile(0.75)

stats_text = f"""
**Salary Statistics:**

- **Median**: ${median_salary:,.0f}
- **Mean**: ${mean_salary:,.0f}
- **25th Percentile**: ${q25_salary:,.0f}
- **75th Percentile**: ${q75_salary:,.0f}
"""

display(Markdown(stats_text))
```

## Geographic Salary Analysis

Where you work significantly impacts compensation.

```{python}
#| label: geographic-analysis

# Use abstraction layer for geographic analysis
from src.visualization import SalaryVisualizer

visualizer = SalaryVisualizer(df)
fig = visualizer.create_geographic_salary_bar_chart()

display_figure(fig, "geographic_salary_comparison")
```

## Simple Salary Prediction

We can predict salary ranges based on key factors using simple machine learning.

```{python}
#| label: simple-prediction

# Simple correlation analysis (no PySpark needed)
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import r2_score, mean_squared_error

# Filter out rows with null salaries
valid_salary_mask = df[salary_col].notna()
df_model = df[valid_salary_mask].copy()

print(f"Training data: {len(df_model):,} records with salary information")

# Simple feature engineering
features = []

# Experience (if available)
if 'min_years_experience' in df_model.columns:
    df_model['experience_clean'] = df_model['min_years_experience'].fillna(0)
    features.append('experience_clean')

# City (top 10 only to avoid too many categories)
if city_col in df_model.columns:
    top_cities = df_model[city_col].value_counts().head(10).index
    df_model['city_top10'] = df_model[city_col].apply(lambda x: x if x in top_cities else 'Other')
    le_city = LabelEncoder()
    df_model['city_encoded'] = le_city.fit_transform(df_model['city_top10'])
    features.append('city_encoded')

# Industry (if available) - use the correct column name
industry_col = 'industry' if 'industry' in df_model.columns else 'naics2_name'
if industry_col in df_model.columns:
    le_industry = LabelEncoder()
    df_model['industry_encoded'] = le_industry.fit_transform(df_model[industry_col].fillna('Unknown'))
    features.append('industry_encoded')

print(f"Features to use: {features}")
print(f"DataFrame shape: {df_model.shape}")

if len(features) > 0:
    # Prepare data
    X = df_model[features].fillna(0)
    y = df_model[salary_col]

    print(f"Feature matrix shape: {X.shape}")
    print(f"Target vector shape: {y.shape}")

    if X.shape[0] > 0 and X.shape[1] > 0:
        # Train simple linear regression
        model = LinearRegression()
        model.fit(X, y)

        # Make predictions
        y_pred = model.predict(X)

        # Calculate metrics
        r2 = r2_score(y, y_pred)
        rmse = np.sqrt(mean_squared_error(y, y_pred))

        print(f"\nModel Performance:")
        print(f"- R²: {r2:.3f}")
        print(f"- RMSE: ${rmse:,.0f}")
        print(f"- Features used: {features}")

        # Show feature importance
        if hasattr(model, 'coef_'):
            print(f"\nFeature Importance:")
            for i, feature in enumerate(features):
                print(f"- {feature}: {model.coef_[i]:.2f}")
    else:
        print("❌ No valid data for training (empty feature matrix)")
        r2 = 0
        rmse = 0
else:
    print("❌ No suitable features found for prediction")
    r2 = 0
    rmse = 0
```

```{python}
#| label: model-results
#| output: asis

from IPython.display import Markdown, display

# Simple results display
results_text = f"""
### Machine Learning Results:

**Model Performance:**

- **R² Score**: {r2:.3f} (explains {r2*100:.1f}% of salary variance)
- **Root Mean Square Error**: ${rmse:,.0f}
- **Training Samples**: {len(df_model):,}

**Features Used** ({len(features)} features):

{chr(10).join(f"- `{feat}`" for feat in features)}

*These features were identified as the strongest predictors of salary based on the data analysis.*
"""

display(Markdown(results_text))
```

## Key Insights for Job Seekers

Based on the predictive models and analysis above, here are data-driven recommendations:

### Location Strategy

*Insights from the [Geographic Salary Analysis](#geographic-salary-analysis) chart:*

- **Target high-paying markets** identified in the geographic analysis above
- Consider **cost of living** alongside salary when evaluating offers
- **Remote opportunities** may offer flexibility while maintaining competitive salaries
- Use the salary prediction model to estimate your earning potential in different cities

### Career Planning

*Insights from the [Machine Learning Model](#simple-salary-prediction) results:*

- **Experience matters**: Our model shows salary progression across career stages
- **Specialization pays**: Certain skills and titles command premium compensation
- **Market awareness**: Understanding salary ranges strengthens negotiations
- The ML model explains **{r2*100:.1f}% of salary variance**, showing predictable patterns

### How to Use This Analysis

1. **Benchmark your offers** against the median salary (${median_salary:,.0f}) and predicted ranges
2. **Identify high-opportunity markets** using the geographic salary chart above
3. **Plan skill development** in areas that correlate with higher salaries
4. **Estimate your market value** using the factors identified by the ML model

---

```{python}
#| label: footer-text
#| output: asis

from IPython.display import Markdown, display
display(Markdown(f"*Analysis based on {len(df):,} real job postings. Data is continuously updated to reflect current market conditions.*"))
```
