---
title: "Predictive Analytics"
subtitle: "Machine Learning Insights for Job Market Analysis"
format:
  html:
    theme: cosmo
    toc: true
    code-fold: true
    code-tools: true
    embed-resources: true
    css: styles.css
execute:
  echo: false
  warning: false
  message: false
---

## Overview

This page demonstrates basic predictive analytics using the job market data. We focus on simple, interpretable models that provide actionable insights for job seekers.

```{python}
#| label: data-loading

# Load processed data using centralized pipeline
from src.data import load_analysis_data
from src.config.column_mapping import get_analysis_column
import pandas as pd
import numpy as np

print("Loading data...")
df = load_analysis_data("predictive")

# Get standardized column names
salary_col = get_analysis_column('salary')
city_col = get_analysis_column('city')

print(f"âœ… Loaded {len(df):,} records")
print(f"   Salary column: {salary_col}")
print(f"   Location column: {city_col}")
```

## Salary Distribution Analysis

Understanding the overall salary landscape helps set realistic expectations.

```{python}
#| label: salary-distribution

import plotly.express as px
import plotly.graph_objects as go

# Create salary distribution visualization
fig = px.histogram(
    df,
    x=salary_col,
    nbins=50,
    title="Salary Distribution in Tech Job Market",
    labels={salary_col: "Annual Salary ($)"},
    color_discrete_sequence=['#3498db']
)

# Add median line
median_salary = df[salary_col].median()
fig.add_vline(
    x=median_salary,
    line_dash="dash",
    line_color="red",
    annotation_text=f"Median: ${median_salary:,.0f}",
    annotation_position="top"
)

fig.update_layout(
    height=500,
    showlegend=False,
    xaxis_title="Annual Salary ($)",
    yaxis_title="Number of Jobs"
)

fig.show()

# Print key statistics
print(f"\nðŸ“Š Salary Statistics:")
print(f"   Median: ${median_salary:,.0f}")
print(f"   Mean: ${df[salary_col].mean():,.0f}")
print(f"   25th percentile: ${df[salary_col].quantile(0.25):,.0f}")
print(f"   75th percentile: ${df[salary_col].quantile(0.75):,.0f}")
```

## Geographic Salary Analysis

Where you work significantly impacts compensation.

```{python}
#| label: geographic-analysis

# Use abstraction layer for geographic analysis
from src.visualization import SalaryVisualizer

visualizer = SalaryVisualizer(df)
fig = visualizer.plot_salary_by_category(city_col)
fig.update_layout(title="Top Cities by Median Salary", height=600)
fig.show()
```

## Simple Salary Prediction

We can predict salary ranges based on key factors.

```{python}
#| label: simple-prediction

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_absolute_error

# Prepare data for simple prediction
# Use city, title, and industry as predictors
prediction_features = []
feature_names = []

# Encode top 10 cities
top_10_cities = df[city_col].value_counts().head(10).index
for city in top_10_cities:
    col_name = f'city_{city}'
    df[col_name] = (df[city_col] == city).astype(int)
    prediction_features.append(col_name)
    feature_names.append(col_name)

# Encode top 10 titles
if 'title' in df.columns:
    top_10_titles = df['title'].value_counts().head(10).index
    for title in top_10_titles:
        col_name = f'title_{title[:20]}'  # Truncate long titles
        df[col_name] = (df['title'] == title).astype(int)
        prediction_features.append(col_name)
        feature_names.append(col_name)

# Prepare features and target
X = df[prediction_features].fillna(0)
y = df[salary_col]

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train simple linear regression
model = LinearRegression()
model.fit(X_train, y_train)

# Evaluate
y_pred = model.predict(X_test)
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)

print(f"\nðŸ¤– Simple Salary Prediction Model:")
print(f"   RÂ² Score: {r2:.3f} (explains {r2*100:.1f}% of variance)")
print(f"   Mean Absolute Error: ${mae:,.0f}")
print(f"   Training samples: {len(X_train):,}")
print(f"   Test samples: {len(X_test):,}")

# Feature importance (top 5)
feature_importance = pd.DataFrame({
    'feature': feature_names,
    'coefficient': model.coef_
}).sort_values('coefficient', ascending=False)

print(f"\nðŸ“ˆ Top 5 Salary Boosters:")
for idx, row in feature_importance.head(5).iterrows():
    feature_name = row['feature'].replace('city_', '').replace('title_', '')
    print(f"   {feature_name}: +${row['coefficient']:,.0f}")
```

## Key Insights for Job Seekers

Based on the analysis above, here are actionable recommendations:

### ðŸŽ¯ Location Strategy
- **Highest paying markets** are visible in the geographic analysis above
- Consider **cost of living** alongside salary when evaluating offers
- **Remote opportunities** may offer flexibility while maintaining competitive salaries

### ðŸ’¼ Career Planning
- **Experience matters**: Salary generally increases with career progression
- **Specialization pays**: Certain skills and titles command premium compensation
- **Market awareness**: Understanding salary ranges helps in negotiations

### ðŸ“Š Using This Analysis
1. **Benchmark your offers** against median salaries in your target location
2. **Identify high-opportunity markets** for relocation or remote work
3. **Plan skill development** in areas that show strong salary correlation

---

*Analysis based on {len(df):,} real job postings. Data is continuously updated to reflect current market conditions.*
